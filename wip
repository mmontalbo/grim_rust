#!/usr/bin/env python3
"""Render the WIP document from the JSON source of truth."""

from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import Iterable, List, Optional


ROOT = Path(__file__).resolve().parent
STATE_PATH = ROOT / "wip_state.json"
DEFAULT_OUTPUT = ROOT / "wip.md"


def load_state(path: Path) -> dict:
    try:
        data = json.loads(path.read_text())
    except FileNotFoundError as exc:
        raise SystemExit(f"{path} is missing. Update the WIP JSON before rendering.") from exc
    except json.JSONDecodeError as exc:
        raise SystemExit(f"{path} could not be parsed: {exc}") from exc
    if not isinstance(data, dict):
        raise SystemExit(f"{path} must contain a JSON object.")
    return data


def append_lines(buffer: List[str], lines: Iterable[str]) -> None:
    for line in lines:
        buffer.append(line.rstrip())


def render_markdown(state: dict) -> str:
    parts: List[str] = []
    title = state.get("title", "Work in Progress")
    parts.append(f"# {title}")

    for section in state.get("sections", []):
        section_title = section.get("title", "Section")
        body = section.get("body", [])
        parts.append("")
        parts.append(f"## {section_title}")
        append_lines(parts, body)

    workstreams = state.get("workstreams", [])
    if workstreams:
        parts.append("")
        parts.append("## Workstreams")
        for stream in workstreams:
            slug = stream.get("slug", "<unnamed>")
            description = stream.get("description", "")
            prompt = stream.get("prompt", "")

            parts.append("")
            parts.append(f"### {slug}")
            if description:
                parts.append(description)
            if prompt:
                parts.append("")
                parts.append("```")
                parts.extend(prompt.rstrip().splitlines())
                parts.append("```")

    # Ensure the output ends with a newline for POSIX friendliness.
    rendered = "\n".join(parts).rstrip()
    return f"{rendered}\n"


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Render the WIP document from wip_state.json."
    )
    parser.add_argument(
        "--write",
        action="store_true",
        help=f"Write the rendered document to {DEFAULT_OUTPUT.relative_to(ROOT)}.",
    )
    parser.add_argument(
        "--out",
        type=Path,
        help="Write the rendered document to the given path.",
    )
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    state = load_state(STATE_PATH)
    output = render_markdown(state)

    target: Optional[Path] = args.out
    if target is None and args.write:
        target = DEFAULT_OUTPUT

    if target is not None:
        target.write_text(output)
    else:
        print(output, end="")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
