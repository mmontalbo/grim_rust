{
  "title": "Work in Progress",
  "sections": [
    {
      "title": "Current Direction",
      "body": [
        "- Pivoted away from patching the original executable; the repository now documents the shipping boot flow and builds a Rust analysis toolchain that can reason about the Lua sources directly.",
        "- Decomposed legacy Lua quirks so `full_moon` can parse every decompiled file without fallback string hacks."
      ]
    },
    {
      "title": "Active Threads",
      "body": [
        "- `grim_analysis` parses `_system`, `_sets`, and every room script, building an aggregate of set hooks and the actors they spawn.",
        "- Static simulator groups stateful calls by subsystem (objects, inventory, interest actors, actors, audio, progression) so we can see which engine services the Lua scripts expect.",
        "- JSON report (`--json-report`) persists hook simulations plus any unclassified method calls, helping us track coverage gaps over time.",
        "- Registry shim reads/writes JSON snapshots so repeated runs mimic the original engine's registry mutations (e.g., `GrimLastSet`).",
        "- `grim_formats` now exposes a reusable `LabArchive` reader and `lab_dump` example so we can inspect LAB contents without shell scripts.",
        "- `grim_engine` consumes the shared analysis layer, materialises the stage-aware boot timeline, and now exports per-subsystem deltas alongside an ordered list of subsystem delta events so runtime services can replay mutations without re-parsing Lua. The replay snapshot now tracks actor transforms (position, rotation, facing) plus basic chore state/history, and the timeline manifest fixtures cover the richer schema so downstream tools can rely on it.",
        "- Geometry verification test: `cargo test -p grim_engine` exercises `verify_geometry_round_trip_matches_static_timeline` to ensure the runtime snapshot stays aligned with the static geometry timeline.",
        "- Asset manifests now tag bitmap entries as `classic` vs `unsupported` so the tooling can skip remastered-only surfaces until the codec 3 decompressor exists.",
        "- `grim_viewer` consumes the manifest, decodes codec 0 BM surfaces with the shared loader, and only falls back to a hashed preview when metadata is missing (older manifests) while we finish reversing the remastered payloads. It can now ingest the boot timeline manifest, surface the actors staged during boot, and lets you cycle through them in the viewer (prepping for placements once geometry decoding lands).",
        "- Added a lightweight script/movie scheduler in `grim_engine`; the CLI's `--simulate-scheduler` switch replays the boot queues using that iterator so we can reason about execution order without Lua, and `--scheduler-json` persists the exact boot queue order for downstream tooling.",
        "- Embedded Lua host: `grim_engine --run-lua` now boots an `mlua` VM backed by a shared `EngineContext`, letting the stock `_actors.lua` and `_objects.lua` scripts execute so Manny's Office uses the real object tables. Actor selection, set switches, object state mutations, and inventory changes are logged for comparison against the static analysis. `_colors`, `_controls`, and the music/SFX helpers now install stateful scaffolds that record the current cue, queued transitions, mute state, and active sound handles, while the richer menu helpers remain stubbed so verbose runs still highlight the next bindings we need to land. `start_script`/`single_start_script` now spawn cooperative Lua threads, `break_here` yields through `coroutine.yield`, and the host advances a few frames post-BOOT so long-running trackers stay resident with their yield counts for future bindings."
      ]
    },
    {
      "title": "Next Steps",
      "body": [
        "1. Wire the `--verify-geometry` flow (now exercised by `cargo test -p grim_engine`) into downstream tooling/CI so sector or visibility drift surfaces automatically outside local runs.",
        "2. Keep widening the legacy normalisation pass (additional helper keywords, comment forms) so parsing never regresses.",
        "3. Replace the Manny-specific camera fallback with geometry-driven selection and extend the parser/lookup path to other sets once their data is decoded, using the snapshot diff to keep sector coverage honest.",
        "4. Push the geometry-backed state into the remaining runtime helpers (menu services and the deeper audio routines) so later scenes can react without relying on placeholder logging."
      ]
    },
    {
      "title": "Executable Workstreams",
      "body": [
        "The prompts below can be launched as parallel Codex sessions. Each command assumes the `codex-exec` binary is run from `~/Developer/codex/codex-rs` with the Grim Fandango repo mounted at `/home/mmontalbo/Developer/grim_mod`. Each workstream now runs inside its own git worktree at `artifacts/worktrees/<slug>` on branch `workstream/<slug>`, keeping edits isolated until you review and merge them. Feel free to append additional flags (e.g. `-c model=\"o3\"`) if you need a different profile, but keep the working directory and prompt body intact so each agent starts with the same context we are tracking here.",
        "You can launch them individually or run `./wip continue` to spawn matching Codex sessions in parallel (logs land in `artifacts/workstreams/` by default). The helper uses the same configuration as this session (`--model gpt-5-codex`, `--sandbox danger-full-access`, `approval_policy=\"never\"`). After runs complete, invoke `./wip review` for log + diff summaries, or `./wip iterate` to launch and review in a single step."
      ]
    }
  ],
  "workstreams": [
    {
      "slug": "menu_ui",
      "description": "Menu/UI runtime bindings",
      "prompt": "Run ./wip status to review the current plan, then focus on finishing the Manny menu helpers. Replace the remaining stubs in grim_engine/src/lua_host.rs (search for install_menu_) with stateful implementations that mirror the original Lua behaviour, add regression tests covering menu visibility/autofreeze, run cargo fmt && cargo test -p grim_engine, and prepare a descriptive commit message summarising the menu-runtime work."
    },
    {
      "slug": "audio_bridge",
      "description": "Audio playback bridge",
      "prompt": "Review the new music and sfx scaffolds described in ./wip status, design a minimal playback adapter (feature-gated if needed) that can trigger sample decoding in grim_viewer, update grim_engine/src/lua_host.rs and any shared modules accordingly, add coverage ensuring cues/handles round-trip through the adapter, run cargo fmt && cargo test -p grim_engine -p grim_viewer, and stage a commit summarising the audio bridge."
    },
    {
      "slug": "interaction_loop",
      "description": "Interaction loop polish",
      "prompt": "Run ./wip status for the latest context, then cross-reference the geometry snapshot and interaction state captured by grim_engine --run-lua. Implement the missing object/inventory helpers (see TODOs in grim_engine/src/lua_host.rs around object controls), add integration coverage that walks Manny through the initial office interactions, run cargo fmt && cargo test -p grim_engine, and craft a commit message documenting the interaction-loop milestone."
    }
  ]
}
